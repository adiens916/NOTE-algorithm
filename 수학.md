### 수학

- [10757. 큰 수 A+B](.\Baekjoon_Online_Judge\Step_by_step\07_Basic_math\10757_큰_수_A+B.py)

  - 큰 수는 문자열 배열로 처리
  - 수 길이가 다름 => if를 **각각** 걸고, 자리가 있으면 더하기
  - 자릿수 올림 => 임시 변수 v에 더하고, v //= 10을 해서 자릿수 올리거나 유지
  - 참고: https://www.acmicpc.net/source/19535645

- [2562. 최댓값](.\Baekjoon_Online_Judge\Step_by_step\04_1D_array\2562_최댓값.py)

  - 최댓값 = _max_(list)
  - 최댓값의 위치 = list._index_(max(list))

- [1546. 평균](Baekjoon_Online_Judge/Step_by_step/07_Basic_math/1546_평균.py)

  - 각각의 수에 임의의 값을 곱해서 다시 평균을 내는 경우,  
    그냥 원래 평균에 임의의 값을 곱하는 것과 같음.
  - (C _ a + C _ b + C _ c) / N = C _ avg = new_avg

- [2869. 달팽이는 올라가고 싶다](.\Baekjoon_Online_Judge\Step_by_step\07_Basic_math\2869_달팽이는_올라가고_싶다.py)

  - 마지막 날에 A만큼 가면 끝남.
    => 마지막 전날에 A만큼 남긴 거리를 며칠만에 가는지를 구하기. (역으로 생각하기)

- [1065. 한수](.\Baekjoon_Online_Judge\Step_by_step\05_Function\1065_한수.py)

  - 연속된 등차수열
    1. 기준이 되는 등차를 구하고 (1번 자리 - 0번 자리)
    2. 두 번째 자리부터 비교 (i+1번 자리 - i번 자리)
  - 연속 => 실제로 연속인지 일일이 순회해야 함.
    - 합을 이용해서 쉽게 구하려고 할 수 있으나,  
      합만 같고 순서가 다른 경우 연속된 등차가 아님.

- [1193. 분수찾기](.\Baekjoon_Online_Judge\Step_by_step\07_Basic_math\1193_분수찾기.py)

  - 지그재그 순서 => 계차수열

    ```python
      while line_end_index < X:
          increment += 1
          line_end_index += increment

      # 증분이 짝수면, 최댓값은 첫 열에 있음.
      if increment % 2 == 0:
          # 최댓값과 원하는 값 사이의 거리 구하기
          diff = line_end_index - X
          # 해당 거리만큼 가감해서 원하는 위치 구하기
          row = (increment - 1) - diff
          col = diff
    ```

  - 일반항을 구해서 푸는 듯한 방식들  
    [링크 1](https://www.acmicpc.net/source/27023881)
    [링크 2](https://www.acmicpc.net/source/26387904)

- [2292. 벌집](.\Baekjoon_Online_Judge\Step_by_step\07_Basic_math\2292_벌집.py)

  - 문제 조건에서 규칙성을 찾자.
  - 벌집은 육각형이므로, 6이 배수 형태로 증가.  
    참고: https://www.acmicpc.net/source/12663249

    ```python
    sum = 1
    n = int(input())
    for k in range(0,1000000001):
        sum += (6 * k)

        if sum >= n:
            print(k + 1)
            break
    ```

  - 범위 안에 N이 포함되는지만 확인하면 되므로,  
    그보다 작은 범위는 고려하지 않아도 되었음.

- [1929. 소수 구하기](.\Baekjoon_Online_Judge\Step_by_step\08_Number_Geometry\1929_소수_구하기.py)

  - 소수 판별용 배열 (=에라토스테네스의 채) 생성

    ```python
    def eratosthenes_sieve(max_num: int):
        # 배열을 참으로 초기화 (전부 소수라고 가정)
        prime_table = [True] * (max_num + 1)
        # 0과 1은 소수 아님
        prime_table[:2] = [False, False]

        # 약수의 범위는 제곱근까지
        sqrt = int(max_num ** 0.5)
        for i in range(2, sqrt + 1):
            # 약수가 소수인 경우,
            if prime_table[i]:
                # 배수들은 소수가 아님
                for j in range(i * i, max_num + 1, i):
                    prime_table[j] = False

        return prime_table
    ```

  - 만약 최대 M 범위의 N 개의 숫자들인 경우,  
    매번 수를 나누는 식으로 판별하면 O(N \* M^2)  
    반면 이렇게 나누는 과정을 한 번만 하면 O(N + M^2)...?

- [11653. 소인수분해](.\Baekjoon_Online_Judge\Step_by_step\08_Number_Geometry\11653_소인수분해.py)

  - 소인수분해는 제곱근부터 1씩 줄인 값으로 나눠떨어지는지 확인
    - ∴ 소수 판별도 1/2값이 아니라  
      제곱근부터 시작하면 더 빨리 줄여나갈 수 있을 듯
  - 제곱근은 \*\* 0.5로. math의 sqrt보다 빠름.
  - 오름차순 처리

    - 참고: https://www.acmicpc.net/source/28770680

      ```python
      N = int(input())

      for i in range(2, int(N**0.5)+1):
          while N % i == 0:
              print(i)
              N /= i
          if N == 1:
              break
      ```

  - 내림차순 & 배열 이용
    - 소인수분해하며 나온 합성수들을 배열에 넣고,  
      각각의 합성수들을 계속 소인수분해
      - 오름차순 방식보다 빠르진 않았음...
    - 최대 범위가 10^7일 때, 배열의 크기(소수의 개수)는 최대 24개
      - 가장 작은 소수인 2로만 구성했을 때 24개인데, 그보다 큰 2\*5로는 더 작은 개수일 것이기 때문.
      - ∵ 2^24 > 10^7
